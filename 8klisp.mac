;8KLLISP.MAC
;18 Apr 1986 Alex

INCLUDE 8KLISP.DEF

	EXTRN HEAPTR,SINIT,CELL0,LEVEL,MEMTOP,LDFLG,FREMSG,NXTCHR
	EXTRN PR$HL,PR$PC,MSG$PC,CR_LF,READ,PRINT,PRIN1,OPEN2,UNBOX,BOXHL,BRKEY
	EXTRN TOOLS,TSYM,GC,FILMAX,STEPM,FBASE,CBASE,SELCON,TRET,ALCSYM,BASE,MEMCHK
	EXTRN SSSYM,STEPSYM,ZERO,INIBUF,CLRBUF,CLRBF2,ATSYM

;********************;
; START OF EXECUTION ;
;********************;
COLD::
	LD HL,(6)		;GET TOP OF MEMORY
	LD (MEMTOP),HL	;SAVE IT
	LD SP,HL
	LD (SINIT),HL	;SET INITIAL STACK PTR
	LD A,'0'		;INIT LEVEL PROMPT TO ZERO
	CALL INIT
	LD DE,8			;SET RST TOOLS
	LD HL,TOOLS
	LD BC,40
	LDIR
	CALL INIBUF		;INIT CONSOLE BUFFER TERMINATOR
	CALL FREMSG
	LD A,(DFLTF+3)	;COMMAND LINE ARG?
	CP ' '
	JR Z,WARM		;NO
	LD A,1			;SET LOAD FLAG
	LD (LDFLG),A
	XOR A			;CLEAR REST OF FCB
	LD HL,DFLTF+14
	LD B,24
CL10:
	LD (HL),A
	INC HL
	DJNZ CL10
	LD DE,DFLTF		;DEFAULT FILE
	CALL OPEN2		;OPEN
WARM::
	LD HL,(SINIT)	;GET TOP OF MEMORY
	LD SP,HL		;INIT SP
	LD A,'0'-1		;INIT LEVEL PROMPT TO ONE BELOW ZERO
	CALL INIT
	LD HL,0			;PUSH RETURN TO CP/M
	PUSH HL
REVALO::
	PUSH HL			;SAVE READ CHANNEL
	LD HL,LEVEL
	INC (HL)
REV10:
	POP HL			;CHANNEL
	PUSH HL
	CALL READ		;READ EXPRESSION
	LD DE,TSYM		;T?
	CPDE
	JR NZ,REV20		;NO
	LD HL,LEVEL		;ELSE RETURN
	DEC (HL)
	POP HL			;DROP CHANNEL
	JP TRET			;RETURN T
REV20:
	CALL EVAL		;EVALUATE IT
	LD (ATSYM+1),HL	;SAVE THE RESULT IN '@'
	PRINT "-> "
	CALL SELCON		;CONSOLE
	CALL PRINT		;PRINT RESULT
	JR REV10

;********;
; ERRORS ;
;********;
TYPERR::
	CALL SELCON		;CONSOLE
	CALL PRIN1
	PRINT ": "
ERR::
	CALL SELCON
	POP HL
	CALL PR$HL
ERR10:
	CALL CLRBUF
ERR20:
	MSG " error"
	LD HL,NIL		;CONSOLE
	CALL REVALO
	JR ERR20

;MAPPING PRIMITIVE
MAP1::
	PUSH DE			;PRESERVE FUNCION
	LD (CELL0),HL
	LD HL,CELL0		;MAKE TEMP LIST FROM ARG
	CALL APPLY2
	POP DE			;RESTORE FUNCTION
	RET

;************************************;
; APPLY FUNCTION IN HL TO ARGS IN DE ;
;************************************;
APPLY::
	CALL MLSTDE
APPLY2:
	PUSH HL			;SAVE ARG(S)
	LD H,D			;COPY FUNCTION
	LD L,E
	LD A,H			;NIL?
	OR A
	JR Z,UNDEF		;YES
	LD A,(HL)		;CELL?
	RRCA
	JR C,APLCELL	;YES
	AND 40H			;SYMBOL?
	JR NZ,UNDEF		;NO
	INC HL			;ELSE GET FUNCTION DEFINITION
	INC HL
	INC HL
	FETCH
	LD A,H			;UNDEFINED?
	OR A
	JR Z,UNDEF		;YES
	EX (SP),HL		;FUNDEF IN TOS, ARGS IN HL
	CP HIFSUBR		;SUBR?
	JP C,APLSUBR	;YES
	CP HIHEAP		;FSUBR?
	RET C			;YES
	EX (SP),HL		;ARGS IN TOS, FUNCTION DEFINITION IN HL
	LD A,(HL)		;CELL?
	RRCA
	JR NC,UNDEF		;NO
APLCELL::
	LD E,(HL)		;DUMMY ARGS IN DE
	INC HL
	LD D,(HL)
	INC HL
	LD B,(HL)		;BODY IN BC
	INC HL
	LD C,(HL)
	LD HL,(FBASE)	;PUSH FRAME BASE
	EX (SP),HL		;ACTUAL ARGS IN HL, FRAME LINK IN STACK

STKAPPL::
	LD A,D			;DUMMIES EMPTY?
	OR A
	JP Z,STKBIND	;YES
	LD A,(DE)		;DUMMY ATOMIC?
	RRCA
	JR NC,SA30		;YES
	LD A,H			;ELSE ARGS EMPTY?
	OR A
	JR Z,SA20		;YES
	PUSH DE			;SAVE DUMMIES
	POPLIST			;NEXT ARG IN DE
	EX DE,HL		;ARG IN HL, ARGS IN DE
	EX (SP),HL		;ARG IN STACK, DUMMIES IN HL
	PUSH DE			;SAVE ARG-REST
	POPLIST			;NEXT DUMMY IN DE
	EX DE,HL
	EX (SP),HL		;DUMMY IN (SP), ARGS IN HL
	JR STKAPPL
SA20:
	PUSH HL			;ARGS EMPTY: PUSH NIL
	EX DE,HL		;DUMMIES IN HL
	LD E,(HL)
	INC HL
	LD D,(HL)		;NEXT DUMMY IN DE
	INC HL
	PUSH DE			;SAVE IT AS LOCAL VARIABLE
	LD D,(HL)		;GET DUMMY-REST IN DE
	INC HL
	LD E,(HL)
	LD HL,NIL		;RESTORE EMPTY ARG-LIST
	JR STKAPPL
SA30:
	PUSH HL			;SAVE ARG
	PUSH DE			;AND SYMBOL
	JP STKBIND

APLSUBR::
	POPLIST			;FIRST ARG
	PUSH DE			;SAVE
	POPLIST			;SECOND ARG IN DE
	LD B,H			;THIRD ARG IN BC
	LD C,L
	POP HL			;GET FIRST ARG
	RET

;UNDEFINED FUNCTION
UNDEF::
	EX DE,HL
	CALL SELCON		;CONSOLE
	CALL PRIN1
	PRINT " undef"
	JP ERR10

;***************************;
; EVALUATE EXPRESSION IN DE ;
;***************************;
EVALDE::
	EX DE,HL
;***************************;
; EVALUATE EXPRESSION IN HL ;
;***************************;
EVAL::
	LD A,H			;NIL?
	OR A
	RET Z			;YES
	LD A,(HL)		;GET TAG
	RRCA			;CELL?
	JR C,EVCELL		;YES
	AND 40H			;NUMBER?
	RET NZ			;YES
	INC HL			;ELSE SYMBOL
	LD E,(HL)		;GET VALUE
	INC HL
	LD D,(HL)
	EX DE,HL
	LD A,H			;UNBOUND?
	OR L
	RET NZ			;NO
	DEC DE			;ELSE UNBOUND ERROR
	DEC DE			;BACK TO SYMBOL
	EX DE,HL
	CALL SELCON
	CALL PRIN1
	PRINT " unbound"
	JP ERR10
EVCELL::
	EX AF,AF'		;DECREMENT WATCH-DOG
	DEC A
	CALL Z,BRKTST	;CHECK STEP MODE, CONSOLE AND MEMORY
	EX AF,AF'
	LD E,(HL)		;CAR IN DE
	INC HL
	LD D,(HL)
	INC HL
	LD B,(HL)		;CDR IN BC
	INC HL
	LD C,(HL)
	PUSH BC			;SAVE ARGS
	LD H,D
	LD L,E
	LD A,H			;CAR NIL?
	OR A
	JR Z,UNDEF		;YES
	LD A,(HL)		;CAR CELL?
	RRCA
	JP C,CARCELL	;YES
	AND 40H			;SYMBOL?
	JR NZ,UNDEF		;NO
FUNSYM::
	INC HL			;GET FUNCTION DEFINITION
	INC HL
	INC HL
	LD A,(HL)
	INC HL
	LD H,(HL)		;IN HL
	LD L,A
	LD A,H
	OR A			;UNDEFINED?
	JR Z,UNDEF		;YES
	EX (SP),HL		;FUNDEF IN TOS, ARGS IN HL
	CP HIFSUBR		;SUBR?
	JP C,EVSUBR		;YES
	CP HIHEAP		;FSUBR?
	RET C			;YES
	EX (SP),HL		;ARGS IN TOS, FUNCTION DEFINITION IN HL
	LD A,(HL)		;CELL?
	RRCA
	JR NC,UNDEF		;NO
FUNCELL::
	LD E,(HL)		;DUMMY ARGS IN DE
	INC HL
	LD D,(HL)
	INC HL
	LD B,(HL)		;BODY IN BC
	INC HL
	LD C,(HL)
	LD HL,(FBASE)	;PUSH FRAME BASE
	EX (SP),HL		;ACTUAL ARGS IN HL, FRAME LINK IN STACK
STKEVAL::
	LD A,D			;DUMMIES EMPTY?
	OR A
	JR NZ,SE10		;NO
STKBIND::
	PUSH BC			;SAVE BODY
	LD HL,0			;SET FRAME BASE
	ADD HL,SP
	LD (FBASE),HL
	INC HL
	INC HL
SB10:
	LD E,(HL)		;GET SYMBOL
	INC HL
	LD D,(HL)
	CPDE			;FRAME LINK?
	JR C,POPBODY	;YES: EVALUATE BODY
	INC HL
	INC DE			;ELSE BIND SYMBOL TO VALUE IN STACK
	LD A,(DE)		;LOW(OLD VALUE)
	LD C,A
	LD A,(HL)		;LOW(NEW VALUE)
	LD (DE),A
	LD (HL),C
	INC HL
	INC DE
	LD A,(DE)		;HIGH(OLD VALUE)
	LD C,A
	LD A,(HL)		;HIGH(NEW VALUE)
	LD (DE),A
	LD (HL),C
	INC HL
	JR SB10
POPBODY::
	POP HL			;GET BODY
	PUSH HL			;SAVE AGAIN (FOR GO AND DEBUG)
PBODY2::
	CALL EVBODY
UNBIND::
	EXX				;SAVE RETURN VALUE
UNBND2::
	LD DE,(HEAPTR)	;LOAD TEST LIMIT
	POP HL			;DROP BODY
UB10:
	POP HL			;SYMBOL
	CPDE			;DONE?
	JR NC,UB20		;YES
	POP BC			;VALUE
	INC HL
	LD (HL),C		;RESTORE OLD VALUE
	INC HL
	LD (HL),B
	JR UB10
UB20:
	LD (FBASE),HL	;RESTORE FRAME BASE
	EXX				;GET RETURN VALUE
	RET

RETURN::
	EXX				;SAVE RETURN VALUE
	LD HL,(FBASE)
	LD SP,HL
	JR UNBND2

SE10:
	LD A,(DE)		;DUMMY ATOMIC?
	RRCA
	JR NC,SE30		;YES
	LD A,H			;ELSE ARGS EMPTY?
	OR A
	JR Z,SE20		;YES
	PUSH DE			;SAVE DUMMIES
	PUSH BC			;AND BODY
	POPLIST			;NEXT ARG IN DE
	PUSH HL			;SAVE REST OF ARGS
	CALL EVALDE		;EVALUATE ARGUMENT
	POP DE			;GET ARGS
	POP BC			;AND BODY
	EX (SP),HL		;PUSH EVALUATED ARGUMENT
	PUSH DE			;SAVE ARGS AGAIN
	POPLIST			;NEXT DUMMY IN DE
	EX DE,HL		;DUMMY-REST IN DE
	EX (SP),HL		;DUMMY IN (SP), ARGS IN HL
	JR STKEVAL
SE20:
	PUSH HL			;ARGS EMPTY: PUSH NIL
	EX DE,HL		;DUMMIES IN HL
	LD E,(HL)
	INC HL
	LD D,(HL)		;NEXT DUMMY IN DE
	INC HL
	PUSH DE			;SAVE IT AS LOCAL VARIABLE
	LD D,(HL)		;GET DUMMY-REST IN DE
	INC HL
	LD E,(HL)
	LD HL,NIL		;RESTORE EMPTY ARG-LIST
	JR STKEVAL
SE30:
	PUSH HL			;SAVE ARG
	PUSH DE			;AND SYMBOL
	JR STKBIND

CARCELL::
	CALL EVAL		;EVAL IMPLIED IF
	LD A,H			;RESULT NIL?
	POP HL			;GET BODY
	OR A
	JR Z,IFNIL		;YES
	FETCH			;ELSE EVALUATE T-CONSEQUENT
	JP EVAL			;EVAL AND RETURN
IFNIL::
	POPLIST			;SKIP T-CONSEQUENT
EVBODY::
	POPLIST
	PUSH HL
	CALL EVALDE
	POP DE
	LD A,D			;DONE?
	OR A
	RET Z			;YES
	EX DE,HL
	JR EVBODY

GOERR:
	ERROR "Go"

GO::
	CALL MBYTE
	LD C,A			;SAVE TAG
	LD SP,(FBASE)	;SEARCH BODY FOR TAG
	POP HL
	PUSH HL			;BODY IN HL
GO10:
	LD A,H			;END OF BODY?
	OR A
	JR Z,GOERR		;YES
	POPLIST			;CAR OF BODY IN DE
	LD A,(DE)		;NUMBER?
	AND 81H
	CP 80H
	JR NZ,GO10		;NO
	INC DE
	LD A,(DE)		;SIZE 1?
	CP 1
	JR NZ,GO10		;NO
	INC DE
	LD A,(DE)		;FOUND TAG?
	CP C
	JR NZ,GO10		;NO
	JP PBODY2		;ELSE EVAL REST OF BODY IN HL

EVSUBR::
	LD A,H
	OR A			;END OF ARG-LIST?
	JR Z,NOARGS		;YES
	POPLIST
	PUSH HL			;PUSH REST OF ARGS
	CALL EVALDE		;EVAL FIRST ARG
	POP DE
	LD A,D			;END OF ARGS?
	OR A
	JR Z,ONEARG		;YES
	PUSH HL			;SAVE REST
	EX DE,HL
	POPLIST
	PUSH HL
	CALL EVALDE		;EVAL SECOND ARG
	EX DE,HL		;RESULT IN DE
	POP BC			;THIRD ARG?
	POP HL
	LD A,B
	OR A
	RET Z			;NO
	PUSH HL
	PUSH DE
	LD A,(BC)		;EVAL THIRD ARG
	LD L,A
	INC BC
	LD A,(BC)
	LD H,A
	CALL EVAL
	LD B,H
	LD C,L
	POP DE
	POP HL
	RET

NOARGS::
	LD DE,NIL
ONEARG::
	LD BC,NIL
	RET

;************************;
; TEST FOR CONSOLE BREAK ;
;************************;
BRKTST::
	PUSH HL
	JR C,SSTEP		;SINGLE STEP
	EX AF,AF'
	CALL BRKEY		;ESC-KEY?
	JR C,BRK0		;YES
BT10:
	CALL MEMCHK
	POP HL
	EX AF,AF'
	RET

SSTEP::
	LD A,3			;SET SINGLE STEP MODE FOR LATER
	LD (STEPM),A
	OR A			;CLEAR IT FOR NOW
	EX AF,AF'
	LD DE,NIL		;CONSOLE
	CALL PRINT
	JR BRK10

BRK1::
	PUSH HL
BRK0::
	XOR A			;CLEAR STEP MODE FOR LATER
	LD (STEPM),A
	EX AF,AF'		;AND FOR NOW
	MSG "[Break]"
	CALL CLRBUF
BRK10:
	POP HL
	LD (SSSYM+1),HL	;STORE CURRENT SEXPR IN SS
	PUSH HL
	LD HL,NIL		;CONSOLE
	CALL REVALO		;READ-EVAL LOOP
	POP HL
	LD A,(STEPM)	;GET STEP MODE
	OR A
	RRA				;SET CARRY AND AC ACCORDINGLY
	RET

STOP::
	LD A,H
	OR A			;CONDITION TRUE?
	RET Z			;NO
	CALL BRK1
	EX AF,AF'
	RET

;RESERVE SPACE ABOVE THE STACK
ALLOC::
	EX DE,HL		;GET SECOND ARG
	LD A,H			;NIL?
	OR A
	JR Z,AL10		;YES
	PUSH DE			;SAVE FIRST ARG
	CALL UNBOX		;GET NUMBER IN DEC
	LD B,E			;IGNORE HIGHEST BYTE IN D
	LD HL,(MEMTOP)
	OR A
	SBC HL,BC
	PUSH HL			;SAVE NEW TOP ADDRESS
	CALL BOXHL
	LD (ALCSYM+1),HL;SET VALUE OF ALLOC-SYMBOL
	POP DE			;GET TOP ADDRESS
	POP HL			;AND FIRST ARG
	JR AL20
AL10:
	LD (ALCSYM+1),HL;SET ALLOC'S VALUE TO NIL
	LD HL,(MEMTOP)	;GET TOP OF MEMORY
	EX DE,HL		;INTO DE, FIRST ARG INTO HL
AL20:
	CALL MBYTE		;NUMBER OF FILES (NO SIZE CHECK)
	LD (FILMAX),A	;SET FILE MAXIMUM
	EX DE,HL		;GET TOP OF MEMORY
	OR A			;ANY FILES?
	JR Z,AL40		;NO
	LD B,A			;ELSE INIT COUNT
AL30:
	LD DE,-FILSIZ	;SUBTRACT FILE SIZE
	ADD HL,DE
	LD (HL),0		;CLEAR FILE'S FLAG BYTE
	DJNZ AL30
AL40:
	LD (SINIT),HL	;SET STACK INIT
	JR RESET2

RESET::
	LD HL,(SINIT)
	CALL UNWIND
RESET2:
	CALL CLRBF2
	MSG "[Reset]"
	JP WARM

UNWIND::
	POP IY			;RETURN ADDRESS
	LD (CBASE),HL	;SAVE CORRESPONDING CATCH BASE
	LD DE,(HEAPTR)	;LOAD TEST LIMIT
	LD HL,(FBASE)	;AND UNWIND THE STACK
UW10:
	LD BC,(CBASE)	;NEXT FRAME ABOVE THE CATCH BASE?
	CPBC
	JR NC,UW30		;YES: DONE
	INC HL
	INC HL			;ELSE SKIP BODY
	LD SP,HL		;AND UNBIND THE FRAME
UW20:
	POP HL			;SYMBOL OR FRAME LINK
	CPDE			;THIS FRAME DONE?
	JR NC,UW10		;YES
	POP BC			;VALUE
	INC HL
	LD (HL),C		;RESTORE SYMBOL'S OLD VALUE
	INC HL
	LD (HL),B
	JR UW20
UW30:
	JP (IY)

;**************;
;TYPE CHECKING ;
;**************;
MLSTDE::
	EX DE,HL
MLST::
	LD A,(HL)
	RRCA			;CELL?
	RET C
	CALL TYPERR
	DC "list"

MSYMDE::
	EX DE,HL
MSYM::
	LD A,(HL)
	AND 81H			;SYMBOL
	RET Z			;OK
	CALL TYPERR
	DC "symbol"

MNUMDE::
	EX DE,HL
MNUM::
	LD A,(HL)
	AND 81H
	CP 80H
	RET Z			;OK
	CALL TYPERR
	DC "number"

;MUST BE BYTE, RET Z IF OK
MBYTDE::
	EX DE,HL
MBYTE::
	CALL MNUM		;NEED A NUMBER
	INC HL			;NUMBER SIZE
	LD A,(HL)
	OR A			;ZERO?
	RET Z			;YES
	DEC A			;MUST BE ONE-> ZERO FLAG
	INC HL
	LD A,(HL)		;GET SIZE
	RET Z
	DEC HL
	DEC HL
	CALL TYPERR
	DC "byte"

;A: LEVEL, HL: INITIAL SP
INIT::
	LD (LEVEL),A	;SET LEVEL
	LD (FBASE),HL	;SET FRAME BASE
	LD (CBASE),HL	;AND CATCH BASE
	LD HL,ZERO		;SET STEP TO ZERO
	LD (STEPSYM+1),HL
	LD A,10			;SET RADIX TO 10
	LD (BASE+1),A
	XOR A			;CLEAR STEP FLAG
	EX AF,AF'
	RET

	END
