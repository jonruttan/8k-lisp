;SUBR.MAC
;@ 86/07/15

INCLUDE 8KLISP.DEF

	EXTRN ERR,PR$PC,MSG$PC,SINIT,TEMP,MKSYM,STEPM,SEARCH,ONE,MEMCHK,PROGN
	EXTRN MLST,MLSTDE,MSYM,MSYMDE,MNUM,MNUMDE,FLAG,MAP1,LEFT,RIGHT,$KEY
	EXTRN HEAP,HEAPTR,TSYM,ZERO,BASE,FBASE,CBASE,EQUAL?,SETOPS,BRKEY
	EXTRN PRINT,SPARE,BOXNUM,UNBOX,UNBXDE,MCHKHL,FADRHL,UNWIND
	EXTRN MOOV,ADD1,SUB1,MULT0,DIV0,MOD0,SQRT0,MBYTE,MBYTDE,PROTECT

EPROGN::
	CALL MLST
	JP PROGN

REMOB::
	PUSH HL			;SAVE ARGUMENT
	LD DE,PROTECT
	CPDE
	JR C,RM30
	EX DE,HL		;SYMBOL IN DE
	LD HL,HEAP		;HL ON FIRST SYMBOL IN HEAP
	LD BC,7			;OFFSET TO LINK
RM10:
	ADD HL,BC
	PUSH HL			;SAVE PTR TO LAST SYMBOL'S LINK
	FETCH
	CPDE			;FOUND?
	JR Z,RM20		;YES
	LD A,H			;DONE?
	OR A
	INC SP			;DROP
	INC SP
	JR Z,RM30		;YES
	JR RM10
RM20:
	ADD HL,BC
	FETCH			;GET SECOND LINK
	EX DE,HL		;IN DE
	POP HL			;PTR TO FIRST LINK IN HL
	LD (HL),E
	INC HL
	LD (HL),D		;INSERT LINK
RM30:
	POP HL			;RETURN SYMBOL
	RET

REVERSE::
	CALL MLST
	EX DE,HL		;SECOND ARG SHOULD BE NIL
RV10:
	LD A,D
	OR A
	RET Z
	PUSH HL
	EX DE,HL
	POPLIST
	EX (SP),HL
	EX DE,HL
	CALL CONS
	POP DE
	JR RV10

ASSOC::
	CALL MLSTDE		;LIST IN HL
	LD B,D			;ITEM IN BC
	LD C,E
AS10:
	LD A,H			;LIST EMPTY?
	OR A
	RET Z			;YES
	PUSH HL
	CALL CAAR
	LD D,B
	LD E,C
	PUSH BC
	CALL EQUAL?		;CAR EQUAL TO ITEM?
	POP BC
	POP HL
	JR Z,AS20		;YES
	POPLIST
	JR AS10
AS20:
	FETCH
	RET

MEMBER::
	CALL MLSTDE		;LIST IN HL
	LD B,D			;ITEM IN BC
	LD C,E
MB10:
	LD A,H			;LIST EMPTY?
	OR A
	RET Z			;YES
	PUSH HL
	FETCH
	LD D,B
	LD E,C
	PUSH BC
	CALL EQUAL?		;CAR EQUAL TO ITEM?
	POP BC
	POP HL
	RET Z			;YES
	POPLIST
	JR MB10

MEMQ::
	CALL MLSTDE		;LIST IN HL
	LD B,D			;ITEM IN BC
	LD C,E
MQ10:
	LD A,H			;LIST EMPTY?
	OR A
	RET	Z			;YES
	PUSH HL
	FETCH
	CPBC			;CAR EQ TO ITEM?
	POP HL
	RET Z			;YES
	POPLIST
	JR MQ10

MAPC::
	LD A,H			;LIST EMPTY?
	OR A
	RET Z			;YES
	PUSH DE			;SAVE FUNCTION
	POPLIST
	EX (SP),HL		;RESTLIST IN (SP)
	EX DE,HL		;FUNCTION IN DE, ARG IN HL
	CALL MAP1
	POP HL			;RETRIEVE RESTLIST
	JR MAPC

;RETURN NTH ELEMENT OF LIST
NTH::
	CALL NTHCDR
	FETCH
	RET

;RETURN NTH CDR OF LIST
NTHCDR::
	PUSH DE
	CALL UNBOX		;GET NUMBER
	LD B,E			;IN BC
	POP HL
	CALL MLST
NTH10:
	LD A,B			;ZERO?
	OR C
	RET Z			;YES
	POPLIST
	DEC BC
	JR NTH10

;MAKE SINGLE CHARACTER ATOM FROM NUMBER
CHAR::
	CALL MBYTE
	OR 80H			;SET TERMINATOR
	LD HL,(HEAPTR)
	LD DE,9			;OFFSET TO PNAME
	ADD HL,DE
	LD (HL),A
	JP MKSYM		;MAKE SYMBOL

;THROW THE LOCUS OF CONTROL
THROW::
	PUSH HL			;TAG
	EXX				;SAVE VALUE IN DE'
	POP BC			;GET TAG IN BC
	LD HL,(CBASE)	;GET CATCH BASE
	LD DE,(SINIT)	;END OF STACK
TH10:
	CPDE			;ILLEGAL THROW?
	JR NC,THROWERR	;YES
	LD A,C
	CP (HL)			;FOUND TAG?
	INC HL
	JR NZ,TH20		;NO
	LD A,B
	CP (HL)
	JR Z,TH30		;YES
TH20:
	INC HL
	FETCH			;GET CATCH LINK
	JR TH10			;TRY NEXT
TH30:
	INC HL			;FOUND MATCHING TAG
	CALL UNWIND
	LD H,B
	LD L,C			;GET CATCH BASE IN SP
	LD SP,HL
	POP HL
	LD (CBASE),HL	;RESTORE CATCH BASE
	POP HL
	LD (FBASE),HL	;RESTORE FRAME BASE
	EXX
	EX DE,HL		;RETRIEVE VALUE
	RET

THROWERR:
	ERROR "Throw"

;INTERN SYMBOL
INTERN::
	CALL MSYM		;NEED A SYMBOL
	LD BC,9			;OFFSET TO PNAME
	ADD HL,BC
	CALL SEARCH
	RET C			;FOUND
	LD BC,-9
	ADD HL,BC
	EX DE,HL		;INSERT NEW LINK
	LD (HL),D
	DEC HL
	LD (HL),E
	EX DE,HL		;RETURN VALUE
	RET

PLIST:
	CALL MSYM
PLIST2:
	LD BC,5			;OFFSET TO PLIST
	ADD HL,BC
	RET

;PUT PROPERTY LIST
PUTPL::
	CALL PLIST
	JP SET1			;RETURN LIST

;GET PROPERTY LIST
GETPL::
	CALL PLIST
	FETCH
	RET

;PUT PROPERTY
PUT::
	PUSH BC			;SAVE PROPERTY AS RETURN VALUE
	PUSH HL			;SYMBOL
	PUSH BC			;AND PROPERTY AGAIN
	CALL PLIST		;PLIST IN HL
	FETCH
	PUSH HL			;SAVE PLIST
	LD B,D			;KEY IN BC
	LD C,E
	LD A,H
PT10:
	OR A
	JR Z,PT20		;NOT FOUND
	POPLIST
	EX DE,HL
	CPBC			;COMPARE WITH KEY
	EX DE,HL
	JR Z,PT30		;FOUND
	POPLIST
	JR PT10
PT20:
	POP DE			;GET PLIST
	POP HL			;AND PROPERTY
	PUSH BC			;SAVE KEY
	CALL CONS		;CONS PROPERTY AND PLIST
	EX DE,HL
	POP HL			;KEY
	CALL CONS
	EX DE,HL
	POP HL			;SYMBOL
	CALL PLIST2
	LD (HL),E
	INC HL
	LD (HL),D
	POP HL
	RET
PT30:
	POP DE			;DROP PLIST
	POP DE			;GET PROPERTY
	LD (HL),E		;REPLACE
	INC HL
	LD (HL),D
	POP HL			;DROP SYMBOL
	POP HL			;GET PROPERTY
	RET

;GET PROPERTY
GET::
	CALL PLIST		;PLIST IN HL
	FETCH
	LD B,D			;KEY IN BC
	LD C,E
	LD A,H
GT10:
	OR A			;EMPTY?
	RET Z			;YES: NOT FOUND
	POPLIST			;NEXT INDICATOR IN DE
	EX DE,HL
	CPBC
	EX DE,HL
	JR Z,GT20
	POPLIST			;SKIP VALUE
	JR GT10
GT20:
	POPLIST
	EX DE,HL		;RETURN PROPERTY
	RET

PACK::
	CALL MLST
	PUSH HL
	LD HL,(HEAPTR)	;PTR TO NEW STRING
	LD DE,8			;OFFSET TO PNAME-1
	ADD HL,DE
	LD B,H
	LD C,L			;PTR IN BC
	POP HL
PK10:
	POPLIST			;NEXT SYMBOL
	CALL MSYMDE		;IN HL, RESTLIST IN DE
	PUSH DE			;SAVE RESTLIST
	LD DE,8			;OFFSET TO PNAME-1
	ADD HL,DE
PK20:
	INC HL
	LD A,(HL)		;COPY BYTE
	AND 7FH			;CLEAR BIT 7
	INC BC
	LD (BC),A
	BIT 7,(HL)		;DONE?
	JR Z,PK20		;NO
	POP HL			;RETRIEVE RESTLIST
	LD A,H
	OR A			;NIL?
	JR NZ,PK10		;NO
	LD A,(BC)		;ELSE MARK LAST BYTE
	OR 80H
	LD (BC),A
	JP MKSYM

UNPACK::
	CALL MSYM		;NEED A SYMBOL
	PUSH HL			;PUSH IT
	LD DE,8			;CALCULATE INDEX TO END OF PNAME
UP10:
	POP HL
	PUSH HL
	INC DE
	ADD HL,DE
	BIT 7,(HL)
	JR Z,UP10
	PUSH DE			;PUSH INDEX
	LD BC,NIL
	PUSH BC			;PUSH RESULT
UP20:
	POP BC			;RESULT
	POP DE			;INDEX
	POP HL			;SYMBOL
	LD A,8			;DONE?
	CP E
	JR Z,UPRET		;YES
	PUSH HL			;SAVE SYMBOL AGAIN
	ADD HL,DE		;POINT TO NEXT CHAR
	DEC DE			;DECREMENT INDEX
	PUSH DE			;AND SAVE
	PUSH BC
	LD A,(HL)		;MAKE SINGLE-CHAR ATOM
	OR 80H
	LD HL,(HEAPTR)
	LD DE,9
	ADD HL,DE
	LD (HL),A
	CALL MKSYM
	POP DE			;RESULT UTIL NOW
	CALL CONS
	PUSH HL			;SAVE NEW RESULT
	JR UP20			;CONTINUE
UPRET:
	LD H,B			;GET RESULT
	LD L,C
	RET

;SET VALUE
SET::
	CALL MSYM
SET0::
	INC HL
SET1::
	LD (HL),E
	INC HL
	LD (HL),D
	EX DE,HL
	RET

;RETRIEVE FUNCTION DEFINITION
GETD::
	CALL MSYM
	INC HL
	INC HL
	INC HL
	FETCH
	LD A,H
	OR A			;NIL?
	RET Z			;YES
	CP HIHEAP		;CODE?
	RET NC			;NO
	JP BOXHL

;SET FUNCTION DEFINITION
PUTD::
	JP DOPUTD##

;SINGLE STEP MODE
STEP::
	LD A,3			;SET STEPMODE
	JR RN10
RUN::
	XOR A			;CLEAR STEPMODE
RN10:
	LD (STEPM),A
	RET

;DESTRUCTIVE REPLACEMENT
RPLCA::
	CALL MLST
	LD (HL),E
	INC HL
	LD (HL),D
	DEC HL
	RET

MPCAN::
	LD A,H			;LIST EMPTY?
	OR A
	RET Z			;YES
	PUSH DE			;SAVE FUNCTION
	POPLIST
	EX (SP),HL		;CDR IN (SP)
	EX DE,HL		;FUNCTION IN DE, CAR IN HL
	CALL MAP1		;APPLY FUNCTION TO CAR
	EX (SP),HL		;SAVE RESULT, GET CDR
	CALL MPCAN		;RECURSE
	EX DE,HL
	POP HL
NCONC::
	LD A,H			;FIST LIST EMPTY?
	OR A
	JR NZ,NC10		;NO
	EX DE,HL		;ELSE RETURN SECOND LIST
	RET
NC10:
	CALL MLST
	PUSH HL			;SAVE RETURN VALUE
	LD BC,MAXLST
	PUSH DE			;SAVE SECOND LIST
NC20:
	LD D,H			;SAVE PTR
	LD E,L
	CALL CDR
	LD A,H
	OR A			;END OF FIRST LIST?
	JR Z,NC30		;YES
	DEC C
	JR NZ,NC20		;CHECK FOR CIRCULAR LIST
	DJNZ NC20
TOOLONG::
	ERROR "Circ"
NC30:
	EX DE,HL		;GET PTR TO LAST CELL IN HL
	POP DE			;RETRIEVE SECOND LIST
	JR RPLCD2		;REPLACE CDR

RPLCD::
	CALL MLST
	PUSH HL
RPLCD2::
	INC HL
	INC HL
	LD (HL),D
	INC HL
	LD (HL),E
	POP HL
	RET

;SYSTEM CALLS
BIOS::
	CALL MBYTE		;OFFSET
	LD HL,BOXA		;PUSH RETURN ADDRESS
	PUSH HL
	LD HL,(01)		;GET BOOT ADDRESS
	ADD A,L			;ADD OFFSET
	LD L,A
	ADC A,H
	SUB L
	LD H,A
	PUSH HL			;SAVE JUMP ADR
	PUSH BC			;SAVE DE-VALUE
	CALL UNBXDE		;GET BC-VALUE
	LD B,E
	POP HL			;DE-VALUE
	PUSH BC			;SAVE BC-VALUE
	CALL UNBOX		;GET DE-VALUE
	LD D,E
	LD E,C
	POP BC
	RET

BDOS::
	CALL MBYTE		;GET SYSTEM CALL NUMBER
	LD C,A
	LD A,D			;SECOND ARG?
	OR A
	JR Z,BD10		;NO
	PUSH BC
	CALL UNBXDE		;ELSE GET ARGUMENT
	LD D,E			;IN DE
	LD E,C
	POP BC
BD10:
	CALL 5			;CALL BDOS
	JR BOXHL

;MEMORY ACCESS OPERATOR
AT_OP::
	PUSH DE			;SAVE SECOND ARG
	CALL UNBOX		;GET ADDRESS
	LD B,E			;IN BC
	LD A,(BC)		;PEEK BYTE
	LD L,A
	POP DE			;SECOND ARG
	LD A,D
	OR A			;EMPTY?
	JR Z,BOXL		;YES
	CALL MBYTDE		;GET BYTE
	LD (BC),A		;POKE NEW VALUE
	EX DE,HL
	JR BOXL			;RETURN OLD VALUE

LENGTH::
	LD DE,0			;INIT COUNT
	LD BC,MAXLST
LN10:
	LD A,H			;EMPTY?
	OR A
	JR Z,BOXDE		;YES
	LD A,(HL)
	RRCA			;ATOMIC?
	JR NC,BOXDE		;YES
	INC DE
	CALL CDR2
	EX DE,HL
	CPBC			;MAX?
	JR Z,TOOLONG	;YES
	EX DE,HL
	JR LN10

MFREE::
	LD HL,-SAFETY	;RESERVE SAFETY SPACE
	ADD HL,SP
	LD BC,(HEAPTR)
	SBC HL,BC
	JR BOXHL

RADIX::
	CALL MBYTE		;NEED BYTE
	LD HL,BASE+1
	LD B,(HL)		;GET OLD RADIX
	LD (HL),A		;SET NEW ONE
BOXB:
	LD L,B
	JR BOXL

;RAW CONSOLE INPUT
KEY::
	CALL $KEY
	JR Z,KEY
	JR BOXA

;RETURN ASCII VALUE OF FIRST CHAR
ASCII::
	CALL MSYM
	LD DE,9				;OFFSET TO PNAME
	ADD HL,DE
	LD A,(HL)
	AND 7FH				;STRIP MSB
BOXA::
	LD L,A
BOXL::
	LD H,0
BOXHL::
	EX DE,HL
BOXDE::
	LD C,0			;ZERO HIGHEST BYTE
;****************************;
; BOX UNSIGNED NUMBER IN CDE ;
;****************************;
BOXCDE::
	LD HL,(HEAPTR)
	INC HL			;SKIP TAG BYTE
	XOR A
	CP C			;HIGHEST BYTE
	JR Z,BH10
	LD (HL),3
	JR BH40
BH10:
	CP D			;MIDDLE BYTE
	JR Z,BH20
	LD (HL),2
	JR BH40
BH20:
	CP E			;LOWEST BYTE
	JR Z,BH30
	LD (HL),1
	JR BH40
BH30:
	LD (HL),0		;ALL ZERO
	JR BOXRET
BH40:
	INC HL
	LD (HL),E		;STORE 3 BYTES
	INC HL
	LD (HL),D
	INC HL
	LD (HL),C
BOXRET:
	JP BOXNUM

MUST2NUM::
	CALL MNUM
	EX DE,HL
	CALL MNUM
	EX DE,HL
	RET

;*************;
; ARITHMETICS ;
;*************;
ONEADD::
	LD DE,ONE
ADD::
	CALL MUST2NUM
	PUSH HL
	CALL SETOPS
	EX DE,HL
	POP HL
	INC HL
	LD A,(DE)
	XOR (HL)
	JP M,ADD10
	CALL ADD1
	JP BOXNUM
ADD10:
	CALL SUB1
	JP BOXNUM

ONESUB::
	LD DE,ONE
SUB::
	LD A,D			;NEGATION?
	OR A
	JR Z,NEGATE
	CALL MUST2NUM
	PUSH DE
	EX DE,HL
	CALL SETOPS
	EX DE,HL
	POP HL
	INC HL
	LD A,(DE)
	XOR (HL)
	JP P,ADD10
	CALL ADD1
	JP BOXNUM

NEGATE::
	CALL MNUM
	EX DE,HL
	CALL SETOPS
	LD A,(HL)
	OR A
	JR Z,NG10
	XOR 80H
	LD (HL),A
NG10:
	JP BOXNUM

MULT::
	CALL MUST2NUM
	PUSH HL
	CALL SETOPS
	EX DE,HL
	POP HL
	INC HL
	CALL MULT0
	JP BOXNUM

DIV::
	CALL MUST2NUM
	PUSH DE
	EX DE,HL
	CALL SETOPS
	EX DE,HL
	POP HL
	INC HL
	CALL DIV0
	JP BOXNUM

MODLS::
	CALL MUST2NUM
	PUSH DE
	EX DE,HL
	CALL SETOPS
	EX DE,HL
	POP HL
	INC HL
	CALL MOD0
	JP BOXNUM

SQRT::
	CALL MNUM
	EX DE,HL
	CALL SETOPS
	EX DE,HL
	CALL SQRT0
	JP BOXNUM

HALF::
	CALL MNUM
	EX DE,HL
	CALL SETOPS
	CALL RIGHT
	JP BOXNUM

DOUBLE::
	CALL MNUM
	EX DE,HL
	CALL SETOPS
	CALL LEFT
	JP BOXNUM

ABS::
	CALL MNUM
	EX DE,HL
	CALL SETOPS
	RES 7,(HL)
	JP BOXNUM

;SHOW STACK
SS::
	LD HL,(SINIT)
	LD DE,-4		;SKIP RET TO CP/M AND TOP-LEVEL REVALO READ CHANNEL
	ADD HL,DE
	PUSH HL			;STACK INDEX
SS10:
	POP HL
	PUSH HL
	LD BC,-7		;DON'T COUNT RET-ADR, INDEX AND BREAK-REVALO READ CHANNEL
	ADD HL,BC		;(CARRY SET)
	SBC HL,SP		;DONE?
	POP HL			;GET INDEX
	JR C,TRET		;YES
	DEC HL			;NEXT STACK ENTRY
	LD D,(HL)
	DEC HL
	LD E,(HL)
	PUSH HL			;SAVE INDEX
	CPDE			;FRAME LINK?
	JR C,SS10		;YES: PRINT NOTHING
	LD A,D			;UNBOUND VALUE?
	OR E
	JR NZ,SS15		;NO
	MSG "[void]"
	JR SS10
SS15:
	LD A,D			;NIL?
	OR A
	JR Z,SS20		;YES
	CP HIHEAP		;CODE?
	JR C,SS10		;YES - PRINT NOTHING
SS20:
	EX DE,HL		;PRINT ITEM
	LD DE,NIL		;TO CONSOLE
	CALL PRINT
	CALL BRKEY		;ESC?
	JR NC,SS10		;NO
	POP HL
	JR NILRET		;ELSE RETURN NIL

;**********************;
; TEST FOR END OF FILE ;
;**********************;
EOFP::
	CALL FADRHL
	LD A,(DE)
	AND 10H			;BIT 4?
	JP NZ,TRET		;YES
	JP NILRET

;*******************;
; CONDITIONAL TESTS ;
;*******************;
ATOM::
	LD A,H			;NIL?
	OR A
	JR Z,TRET		;YES->ATOM
	BIT 0,(HL)
	JR Z,TRET
	JR NILRET

PAIR::
	BIT 0,(HL)
	JR NZ,TRET
	JR NILRET

SYMBOL::
	LD A,(HL)
	AND 81H
	JR Z,TRET
	JR NILRET

BOUNDP::
	CALL MSYM
	INC HL
	LD A,(HL)
	INC HL
	OR (HL)
	JR NZ,TRET
	JR NILRET

NUMBER::
	LD A,(HL)
	AND 81H
	CP 80H
	JR Z,TRET
	JR NILRET

EQUAL::
	CALL EQUAL?
	JR Z,TRET
	JR NILRET

C_EQ::
	CPDE			;POINTER EQUALITY?
	JR NZ,NILRET	;NO
;**********;
; RETURN T ;
;**********;
TRET::
	LD HL,TSYM
	RET

L_NOT::
	LD A,H
	OR A
	JR Z,TRET
;************;
; RETURN NIL ;
;************;
NILRET::
	LD HL,NIL
	RET

ZEROP::
	CALL MNUM
	INC HL
	LD A,(HL)
	OR A
	JR Z,TRET
	JR NILRET

MINUSP::
	CALL MNUM
	INC HL
	BIT 7,(HL)
	JR NZ,TRET
	JR NILRET

ODDP::
	CALL MNUM
	INC HL
	LD A,(HL)
	OR A			;ZERO?
	JR Z,NILRET
	INC HL
	BIT 0,(HL)
	JR NZ,TRET
	JR NILRET

;COMPARE LISTS
LSTLT::
	LD A,H			;FIRST ARG NIL?
	OR A
	RET Z			;YES: RETURN NIL
	FETCH			;CAR OF FIRST ARG
	EX DE,HL
	CALL CAR		;AND OF SECOND (TYPE CHECK)
	EX DE,HL

;COMPARE NUMBERS, SYMBOLS OR LISTS
LESSP::
	LD A,(HL)		;FIRST ARG
	RRCA			;LIST?
	JR C,LSTLT		;YES
	AND 40H			;SYMBOL?
	JR Z,SYMLT		;YES
	CALL MUST2NUM	;ELSE MUST BE 2 NUMBERS
	EX DE,HL
	INC HL
	INC DE
	CALL SPARE
	JR C,TRET
	JR NILRET

;COMPARE SYMBOLS
SYMLT::
	CPDE			;EQUAL?
	JR Z,NILRET		;YES: NOT LESS
	LD BC,8			;OFFSET TO PNAME-1
	ADD HL,BC
	CALL MSYMDE		;SECOND ONE MUST BE A SYMBOL, TOO
	ADD HL,BC		;ADD OFFSET
SLT10:
	INC DE
	INC HL
	LD A,(DE)		;GET CHAR FROM FIRST ARG
	AND 7FH
	LD B,A
	LD A,(HL)		;COMPARE TO CHAR FROM SECOND
	AND 7FH
	CP B
	JR Z,SLT20		;CHARS ARE EQUAL
	JR C,NILRET
	JR TRET
SLT20:
	LD A,(DE)
	RLA				;END OF FIRST?
	JR C,TRET		;YES: SECOND NOT ENDED (NOT EQUAL)
	LD A,(HL)
	RLA				;END OF SECOND?
	JR C,NILRET		;YES:
	JR SLT10

MAXMIN:
	PUSH HL			;SAVE ARGS
	PUSH DE
	CALL LESSP		;COMPARE
	LD A,H			;GET RESULT
	POP DE
	POP HL
	OR A
	RET

MAX::
	CALL MAXMIN		;FIRST LESS THAN SECOND?
	RET Z			;NO: RETURN FIRST
	EX DE,HL		;ELSE RETURN SECOND
	RET

MIN::
	CALL MAXMIN		;FIRST LESS THAN SECOND?
	RET NZ			;YES: RETURN FIRST
	EX DE,HL		;ELSE RETURN SECOND
	RET

DELETE::
	CALL MLSTDE
DL10:
	LD A,H			;EMPTY?
	OR A
	RET Z			;YES
	PUSH HL
	PUSH DE
	PUSH HL
	FETCH			;CAR
	CALL EQUAL?
	POP HL
	POPLIST
	POP DE
	JR Z,DL20
	CALL DL10		;RECURSE
	EX DE,HL
	POP HL
	FETCH			;CAR
	JR CONS
DL20:
	POP DE			;DROP
	RET				;RETURN CDR

APPEND::
	LD A,H			;FIRST LIST EMPTY?
	OR A
	JR NZ,AP10		;NO
	EX DE,HL		;ELSE RETURN SECOND LIST
	RET
AP10:
	CALL MLST
	PUSH HL
	FETCH
	EX (SP),HL		;SAVE CAR IN STACK
	CALL CDR2		;GET CDR
	CALL APPEND		;RECURSE
	JR POPAP		;CONS WITH CAR

MPCAR::
	LD A,H			;LIST EMPTY?
	OR A
	RET Z			;YES
	PUSH DE			;SAVE FUNCTION
	POPLIST
	EX (SP),HL		;CDR IN (SP)
	EX DE,HL		;FUNCTION IN DE, CAR IN HL
	CALL MAP1		;APPLY FUNCTION TO CAR
	EX (SP),HL		;SAVE RESULT, GET CDR
	CALL MPCAR		;RECURSE
POPAP:
	EX DE,HL
	POP HL
;******************;
; LIST CONSTRUCTOR ;
;******************;
CONS::
	LD B,H			;COPY CAR
	LD C,L
	LD HL,(HEAPTR)
	PUSH HL			;SAVE RETURN VALUE
	LD (HL),C		;STORE CAR
	INC HL
	LD (HL),B
	INC HL
	LD (HL),D
	INC HL
	LD (HL),E
	INC HL
	LD (HEAPTR),HL
	CALL MCHKHL
	POP HL
	RET

NILCONS::
	LD DE,NIL
	JR CONS

;*****************;
; LIST OPERATIONS ;
;*****************;
CAAAR::
	CALL MLST
	FETCH
	JR CAAR
CAADR::
	CALL MLST
	POPLIST
CAAR::
	CALL MLST
	FETCH
	JR CAR
CADAR::
	CALL MLST
	FETCH
	JR CADR
CADDR::
	CALL MLST
	POPLIST
CADR::
	CALL MLST
	POPLIST
CAR::
	CALL MLST
	FETCH
	RET

CDAAR::
	CALL MLST
	FETCH
	JR CDAR
CDADR::
	CALL MLST
	POPLIST
CDAR::
	CALL MLST
	FETCH
	JR CDR
CDDAR::
	CALL MLST
	FETCH
	JR CDDR
CDDDR::
	CALL MLST
	POPLIST
CDDR::
	CALL MLST
	POPLIST
CDR::
	CALL MLST
CDR2::
	INC HL
	INC HL
	LD A,(HL)
	INC HL
	LD L,(HL)
	LD H,A
	RET

	END
