;INOUT.MAC
;16nov86abu

INCLUDE 8KLISP.DEF

	EXTRN MLST,MSYM,MSYMDE,MNUM,BOXHL,BOXCDE,MKSYM,MBYTE
	EXTRN CONS,NILCONS,ERR,MCHKHL,UNBOX,CPYSYM,$KEY,BRKEY
	EXTRN LBP,NXTCHR,LDFLG,IOCHAN,SEARCH,CMPSTR,RESET
	EXTRN HEAPTR,TEMP,FLAG,HEAP,T1,T2,SINIT,NILRET
	EXTRN BASE,SHORT,QUOTSYM,FILMAX,LEVEL,INTSYM
	EXTRN ADD1,MULT0,MOOV,MOD0,PSHL,ZERO,ONE

;ERASE FILE
ERA::
	PUSH HL			;SAVE FILE NAME AS RETURN VALUE
	LD DE,T1		;SPACE FOR FCB
	CALL FFCB1		;FORMAT FCB
	BDOS 19			;DELETE FILE
ERARET:
	POP HL
	CP 255			;FOUND?
	RET NZ			;YES
	JP NILRET		;ELSE RETURN NIL

;RENAME FILE
REN::
	PUSH DE			;SAVE NEW NAME
	LD DE,T1		;SET OLD NAME
	CALL FFCB1
	LD DE,T1+16
	POP HL			;NEW NAME
	PUSH HL			;SAVE AS RETURN VALUE
	CALL FFCB1
	LD DE,T1+16		;ERASE NEW IF EXISTENT
	BDOS 19
	LD DE,T1
	BDOS 23			;RENAME
	JR ERARET

;****************;
; SELECT CONSOLE ;
;****************;
SELCON::
	LD DE,NIL
	LD (IOCHAN),DE
	RET

;**********************;
; RETURN FILE POSITION ;
;**********************;
WHERE::
	CALL FADRMN		;GET FILE PTR
	INC DE
	LD A,(DE)		;GET COUNT
	LD HL,34		;OFFSET TO R0
	ADD HL,DE
	ADD A,A			;SHIFT A LEFT
	LD D,(HL)		;MIDDLE BYTE
	INC HL
	LD C,(HL)		;HIGHEST BYTE
	SRL C			;SHIFT ALL RIGHT
	RR D
	RRA
	LD E,A			;LOWEST BYTE
	JP BOXCDE

;********************
; SET FILE POSITION ;
;*******************;
SEEK::
	PUSH HL			;SAVE POS AS RETURN VALUE
	EX DE,HL
	CALL FADRMN		;FILE IN DE (POS IN HL)
	PUSH DE			;SAVE FILE PTR
	LD A,(DE)		;OPEN FOR READING OR WRITING?
	AND 3
	JP Z,FILERR		;NO
	LD A,(DE)
	OR 3			;ELSE SET READ AND WRITE
	LD (DE),A
	CALL UNBOX		;GET NUMBER INTO DEC
	SLA C			;ADJUST RECORD
	RL E
	RL D
	SRL C
	POP HL			;FILE PTR
	PUSH HL
	INC HL			;SET NEW COUNT
	LD (HL),C
	LD BC,34		;OFFSET TO R0
	ADD HL,BC
	FETCH			;GET RANDOM RECORD NO
	CPDE			;SAME?
	POP HL
	JR Z,SKRET		;YES
	PUSH DE			;SAVE NEW RECORD NO
	CALL WRREC		;ELSE WRITE RECORD IF NECESSARY
	RES 2,(HL)		;CLEAR LOADED FLAG
	LD BC,35		;OFFSET TO R0
	ADD HL,BC
	POP DE
	LD (HL),E		;SET NEW RECORD NO
	INC HL
	LD (HL),D
SKRET:
	POP HL			;RETURN NEW POSITION
	RET

;********************;
; CALCULATE FILE ADR ;
;********************;
FADRMN::
	CALL MNUM		;CONSOLE NOT ALLOWED
FADRHL::
	EX DE,HL
FADRDE::
	PUSH HL			;PRESERVE HL
	EX DE,HL		;CHANNEL NO IN HL
	LD A,H			;NIL?
	OR A
	JR Z,FA20		;YES
	CALL MBYTE
	JP NZ,FILERR
	LD HL,FILMAX
	CP (HL)			;LEGAL FILE NO?
	JP NC,FILERR	;NO
	LD HL,(SINIT)
	OR A
	JR Z,FA20		;CORRECT ADR
FA10:
	LD DE,FILSIZ
	ADD HL,DE
	DEC A
	JR NZ,FA10
FA20:
	EX DE,HL		;FILE ADR IN DE
	POP HL			;RESTORE HL
	RET

;***************************;
; FORMAT FILE CONTROL BLOCK ;
;***************************;
FFCB::
	LD A,H			;NIL?
	OR A
	JR Z,ALLWILD	;YES
FFCB1:
	CALL MLST
	PUSH DE			;SAVE PTR TO FCB
	PUSH DE
	POPLIST			;NAME IN DE
	EX (SP),HL		;SAVE REST OF ARGS, FCB IN HL
	LD B,8			;SIZE FILE NAME
	CALL FNAME
	POP HL			;RETRIEVE REST
	PUSH DE
	POPLIST			;NAME IN DE
	EX (SP),HL		;SAVE REST OF ARGS, FCB IN HL
	LD B,3			;SIZE FILE TYPE
	CALL FNAME
FF10:
	LD B,24			;REST OF FCB
	XOR A			;FILL WITH ZERO
FF20:
	INC DE
	LD (DE),A
	DJNZ FF20
	POP HL
	FETCH			;RETRIEVE POSSIBLE DRIVE SPECIFIER
	POP DE			;AND FCB PTR
	LD A,H			;NIL?
	LD (DE),A
	OR A
	RET Z			;YES - DEFAULT DRIVE
	LD BC,9
	ADD HL,BC		;HL ON NAME
	LD A,(HL)		;GET FIRST LETTER
	AND 1FH			;DRIVE NUMBER
	LD (DE),A
	RET

ALLWILD::
	PUSH DE
	PUSH HL
	LD B,11
	CALL FWILD
	JR FF10

;SET FILE NAME PART
FNAME:
	LD A,D			;NIL?
	OR A
	JR Z,FNNIL		;YES
	CALL MSYMDE		;DE ON FCB, HL ON SYMBOL
	PUSH BC			;SAVE COUNT
	LD BC,9			;OFFSET TO NAME
	ADD HL,BC		;HL ON NAME
	POP BC			;RETRIEVE COUNT
FN10:
	LD A,(HL)		;NEXT CHAR
	AND 7FH
	CP '*'			;WILD CARD?
	JR Z,FWILD
	CP 'z'+1		;TO UPPER
	JR NC,FN20
	CP 'a'
	JR C,FN20
	SUB 32
FN20:
	INC DE
	LD (DE),A
	LD A,(HL)
	RLCA			;LAST CHAR IN NAME?
	JR C,FBLANK		;YES
	INC HL
	DJNZ FN10		;ELSE CONTINUE
	RET
FNNIL:
	EX DE,HL		;FCB IN DE
	INC B			;DUMMY INCREMENT
FBLANK:
	LD A,' '		;FILL WHITH BLANKS
	JR NFILL
FWILD:
	LD A,'?'		;WILD CARD CHARACTER
	INC B
NFILL:
	DEC B			;DONE?
	RET Z			;YES
	INC DE			;ELSE FILL WITH BLANKS
	LD (DE),A
	JR NFILL

;READ RECORD
RDREC::
	BIT 2,(HL)		;ALREADY LOADED?
	RET NZ			;YES
	PUSH HL			;SAVE FILE ADR
	LD DE,38		;OFFSET TO BUFFER
	ADD HL,DE
	EX DE,HL		;BUFFER ADR IN DE
	BDOS 26			;SET DMA
	POP DE			;FILE ADR
	PUSH DE
	INC DE			;FCB ADR
	INC DE
	BDOS 33			;READ RANDOM
	POP HL			;RETRIEVE FILE ADR
	SET 2,(HL)		;SET LOADED
	OR A			;READ PAST EOF?
	RET Z			;NO
	SET 4,(HL)		;ELSE SET EOF
	RET

;WRITE RECORD
WRREC::
	BIT 3,(HL)		;WRITTEN?
	RET Z			;NO
	PUSH HL			;SAVE FILE ADR
	LD DE,38		;OFFSET TO BUFFER
	ADD HL,DE
	EX DE,HL		;BUFFER ADR IN DE
	BDOS 26			;SET DMA
	POP DE			;FILE ADR
	PUSH DE
	INC DE			;FCB ADR
	INC DE
	BDOS 34			;WRITE RANDOM
	POP HL			;RETRIEVE FILE ADR
;	CP 5			;DIRECTORY FULL?
;	JR Z,DSKFUL		;YES
;	CP 6			;PHYSICAL END OF DISK?
;	JR Z,DSKFUL		;YES
 OR A
 JR NZ,DSKFUL
	SET 2,(HL)		;SET LOADED
	RES 3,(HL)		;CLEAR WRITTEN
	RET
DSKFUL:
	ERROR "Disk"

NILNAM::
	DC "nil"

INIBUF::
	XOR A
	LD (LBUF),A
	LD A,' '		;BLANK IN NEXTCHAR
	LD (NXTCHR),A
CLRBUF::
	XOR A
	LD (LDFLG),A	;CLEAR LOAD FLAG
CLRBF2::
	LD HL,LBUF
CB10:
	LD (LBP),HL		;INIT LINE BUFFER PTR
	LD A,(HL)		;FIND END OF LINE
	OR A
	RET Z
	INC HL
	JR CB10

;READ LIST
RDLIST::
	CALL SKIPW
	CP ')'			;END OF LIST?
	JR NZ,RL10		;NO
	CALL GETCHR		;ELSE DISCARD ')'
	JP RETNIL		;RETURN NIL
RL10:
	CP '>'			;END OF SUPER-LIST?
	JP Z,RETNIL		;YES
	CP '.'			;DOTTED PAIR?
	JR NZ,RL20		;NO
	CALL GETCHR		;DISCARD '.'
	CALL READ0		;READ EXPR
	PUSH HL
	CALL SKIPW
	CP '>'			;SUPER?
	JR Z,RL15		;YES
	CALL GETCHR		;ELSE NEED ')'
	CP ')'
RL15:
	POP HL			;RETURN VALUE
	RET Z
READERR::
	ERROR "Read"
RL20:
	CALL READ0
	PUSH HL
	CALL RDLIST
RL30:
	EX DE,HL
	POP HL
	JP CONS

RDSUPER::
	CALL RDLIST		;READ LIST
	CALL GETCHR
	CP '>'			;WAS IT A SUPER-LIST?
	RET Z			;YES
	JR READERR		;ELSE DROP '>'

RDQUOTE::
	LD HL,QUOTSYM
	PUSH HL
	CALL READ0
	CALL NILCONS
	JR RL30

;READ ONE EXPRESSION
READ::
	CALL FADRHL		;GET FILE ADDR
	LD (IOCHAN),DE	;IN I/O CHANNEL
	CALL READ0		;READ ONE EXPRESSION
	JP SELCON		;CLEAR I/O CHANNEL

READ0:
	CALL GTNONW			;SKIP POSSIBLE LEADING WHITE SPACE AND GET ONE CHAR
	CP ')'				;IGNORE CLOSING PAREN
	JR Z,READ0
	CP '>'
	JR Z,READ0
	CP '('				;OPEN PAREN?
	JR Z,RDLIST			;YES-JMP
	CP '<'				;SUPER-BRACKET?
	JR Z,RDSUPER		;YES
	CP "'"				;QUOTE?
	JR Z,RDQUOTE		;YES-JMP
;ATOM: SCAN ONE TOKEN FROM INPUT STREAM INTO HEAP
	LD HL,FLAG		;PRESERVE FIRST CHAR IN A
	LD (HL),0		;CLEAR FLAG: ASSUME VALID NUMBER
	LD HL,(HEAPTR)
	LD DE,9			;OFFSET TO PNAME
	ADD HL,DE
	PUSH HL			;KEEP STRING START ADDRESS
	LD (HL),A		;SAVE FIRST CHAR
	CP '-'
	JR Z,TK40		;SKIP IF POSSIBLY NUMBER
TK10:
	SUB '0'
	JR C,TK30		;< '0' -> NO NUMBER
	CP 10
	JR C,TK20		;<= '9' -> TEST AGAINST RADIX
	CP 17
	JR C,TK30		;< 'A' -> NO NUMBER
	SUB 7
TK20:
	PUSH HL
	LD HL,BASE+1
	CP (HL)
	POP HL
	JR C,TK40
TK30:
	LD (FLAG),A		;CANNOT BE A NUMBER
TK40:
	LD A,(NXTCHR)	;TEST FOR END OF NAME
	CP 33			;WHITE SPACE?
	JR C,TK50		;YES-JMP
	CP ')'			;CLOSING PAREN?
	JR Z,TK50		;YES-JMP
	CP '>'
	JR Z,TK50
	CP '.'			;DOT?
	JR Z,TK50		;YES-JMP
	CALL GETCHR		;NO-NEXT CHAR
	INC HL			;INC PTR
	LD (HL),A		;SAVE CHAR
	JR TK10			;CONTINUE
	;END OF NAME
TK50:
	SET 7,(HL)		;END-OF-STRING MARK
	POP HL			;PTR TO START OF NAME
	LD DE,NILNAM
	CALL CMPSTR
	JR NZ,RD10
RETNIL:
	LD HL,NIL			;RETURN NIL
	RET
RD10:
	CALL SEARCH
	RET C				;FOUND

	;NOT FOUND, TEST FOR NUMBER
NOTFND::
	LD A,(FLAG)
	OR A
	JR Z,MKNUM
	;NOT A NUMBER, MAKE NEW SYMBOL
	PUSH DE			;SAVE PTR TO LAST LINK
	CALL MKSYM		;MAKE NEW SYMBOL
	POP DE
	LD A,(INTSYM+2)	;INTERN THE NEW SYMBOL?
	OR A
	RET Z			;NO
	EX DE,HL		;ELSE INSERT NEW LINK
	LD (HL),D
	DEC HL
	LD (HL),E
	EX DE,HL		;RETURN VALUE
	RET

;CONVERT STRING TO A NUMBER
MKNUM::
	EX DE,HL		;DE POINTS TO STRING
	LD HL,(HEAPTR)	;HL INTO HEAP
	INC HL			;SPACE FOR LENGTH
	LD (HL),0		;INIT VALUE TO ZERO
	LD A,(DE)		;FIRST CHAR
	CP '-'
	PUSH AF			;SAVE SIGN
	JR NZ,MN10
	INC DE			;SKIP MINUS SIGN
MN10:
	EX DE,HL		;DE ON NUMBER
MN20:
	PUSH HL			;SAVE PTR TO STRING
	LD HL,BASE		;HL ON RADIX NODE
	CALL MULT0
	POP HL
	PUSH HL
	LD A,(HL)		;NEXT CHAR
	AND 7FH			;CLEAR MARK
	SUB '0'			;MAKE BINARY
	JR Z,MN35		;JMP IF ZERO
	CP 10
	JR C,MN30
	SUB 7
MN30:
	LD HL,SHORT+1
	LD (HL),A
	DEC HL			;HL ON SHORT
	CALL ADD1
MN35:
	POP HL
	BIT 7,(HL)		;END OF STRING?
	INC HL
	JR Z,MN20		;NO
	POP AF			;GET SIGN
	JR NZ,BOXNUM	;SKIP IF POSITIVE
	LD A,(DE)
	OR A			;VALUE ZERO?
	JR Z,BOXNUM		;YES
	OR 80H			;ELSE SET NEGATIVE
	LD (DE),A
;******************************;
; BOX NUMBER GENERATED IN HEAP ;
;******************************;
BOXNUM::
	LD HL,(HEAPTR)
	INC HL				;GET LENGTH
	LD A,(HL)
	OR A				;ZERO?
	JR Z,BOXZERO		;YES
	ADD A,6				;3 BYTES + ADJUSTMENT TO MULTIPLE OF 4
	AND 07CH
	LD C,A				;SAVE LENGTH
	DEC HL
	PUSH HL				;SAVE RETURN VALUE
	OR 80H				;SET NUMBER FLAG
	LD (HL),A			;INSERT LEADING FLAG BYTE
	LD B,0
	ADD HL,BC
	DEC HL
	LD (HL),C			;INSERT TRAILING TAG BYTE
	INC HL
	LD (HEAPTR),HL		;NEW HEAP PTR
	CALL MCHKHL
	POP HL
	RET

BOXZERO:
	LD HL,ZERO			;RETURN ZERO
	RET

;*****************;
; CHARACTER INPUT ;
;*****************;
GTNONW::
	CALL SKIPW		;SKIP WHITE SPACE AND GET NEXT CHAR
;******************************;
; CHAR IN FROM CURRENT CHANNEL ;
;******************************;
GETCHR::
	PUSH HL
	PUSH BC
	CALL CHRIN
	LD HL,NXTCHR
	LD E,(HL)		;GET LAST
	LD (HL),A		;SAVE NEXT
	LD A,E
	POP BC
	POP HL
	RET

OPEN0::
	PUSH DE
	JR OPEN1
OPEN::
	PUSH DE			;SAVE CHANNEL AS RETURN VALUE
	CALL OPCHAN		;SET FILE ADR
OPEN1::
	PUSH DE
	INC DE			;TO FCB
	INC DE
	CALL FFCB
OPEN10:
	BDOS 15			;OPEN
	CP 0FFH			;ERROR?
	POP HL
	JR Z,OPNERR
	LD (HL),1		;SET READ OPEN
OPNRET:
	INC HL
	LD (HL),0		;FILE PTR := 0
	POP HL
	RET

OPEN2::
	PUSH DE			;DUMMY PUSH
	PUSH DE			;PUSH FILE ADR
	INC DE			;TO FCB
	INC DE
	JR OPEN10

OPCHAN:
	CALL FADRDE		;SET FILE ADR
	LD A,(DE)		;GET FLAG
	AND 3			;ALREADY OPEN?
	RET Z			;NO
OPNERR:
	ERROR "Open"

CREAT0::
	PUSH DE
	JR CREAT1
CREATE::
	PUSH DE			;SAVE CHANNEL AS RETURN VALUE
	CALL OPCHAN
CREAT1::
	PUSH DE
	INC DE			;TO FCB
	INC DE
	CALL FFCB
	PUSH DE
	BDOS 19			;DELETE
	POP DE
	BDOS 22			;MAKE
	CP 0FFH			;ERROR?
	POP HL
	JR Z,CRTERR
	LD (HL),2		;SET WRITE OPEN
	JR OPNRET

FILERR:
	ERROR "File"

CRTERR:
	ERROR "Create"

CLOSE::
	LD A,H			;IGNORE CONSOLE CLOSE
	OR A
	RET Z
	PUSH HL			;SAVE CHANNEL AS RETURN VALUE
	CALL FADRMN		;CHANNEL IN DE
	EX DE,HL		;FILE IN HL
CLOSE0::
	BIT 1,(HL)		;OPEN FOR WRITING?
	JR NZ,CL10		;YES
	BIT 0,(HL)		;OPEN FOR READING?
	JR NZ,CL20		;NO
	JR CLRET
CL10:
	CALL WRREC		;FLUSH
CL20:
	LD (HL),0		;CLEAR FLAGS
	EX DE,HL
	INC DE			;TO FCB
	INC DE
	BDOS 16			;CLOSE
CLRET:
	POP HL
	RET

GETC0::
	BIT 0,(HL)		;OPEN FOR READING?
	JR Z,FILERR		;NO
	CALL RDREC		;READ RECORD
	INC HL
	LD E,(HL)		;GET COUNT
	LD D,0			;BYTE OFFSET IN DE
	DEC HL			;RESTORE FILE ADR
	CALL INCRFP		;INCREMENT RANDOM FILE PTR
	ADD HL,DE		;ADD BYTE OFFSET
	LD DE,38		;AND BUFFER OFFSET TO FILE ADR
	ADD HL,DE
	LD A,(HL)		;GET CHAR FROM BUFFER
	RET

PUTC0::
	BIT 1,(HL)		;OPEN FOR WRITING?
	JR Z,FILERR		;NO
	BIT 0,(HL)		;OPEN ALSO FOR READING?
	JR Z,PC10
	PUSH AF
	CALL RDREC		;YES: READ RECORD
	POP AF
PC10:
	PUSH HL
	INC HL
	LD E,(HL)		;GET COUNT
	LD D,0			;BYTE OFFSET IN DE
	ADD HL,DE		;ADD BYTE OFFSET
	LD DE,37		;AND BUFFER OFFSET TO FILE ADR
	ADD HL,DE
	LD (HL),A		;PUT CHAR IN BUFFER
	POP HL
	SET 3,(HL)		;SET WRITTEN
;INCREMENT RANDOM FILE PTR
INCRFP::
	INC HL			;TO COUNT
	INC (HL)		;INCREMENT
	DEC HL
	RET P			;RETURN IF < 128
	INC HL
	LD (HL),0		;RESET COUNT
	DEC HL
	PUSH DE			;SAVE DE
	CALL WRREC		;WRITE RECORD
	PUSH HL
	LD DE,35		;OFFSET TO R0
	ADD HL,DE
	INC (HL)		;INCREMENT RANDOM RECORD
	JR NZ,IR10
	INC HL
	INC (HL)
IR10:
	POP HL
	POP DE
	RES 2,(HL)		;CLEAR LOADED
	RET

;******************;
; SKIP WHITE SPACE ;
;******************;
SKIPW::
	LD A,(NXTCHR)
	CP 33				;NEXT CHAR WHITE?
	JR NC,SW20			;NO-JMP
SW10:
	CALL CHRIN			;TRY NEXT
	OR A				;VACUUM?
	JP Z,READERR
	CP 33
	JR C,SW10
	LD (NXTCHR),A		;SAVE THE NONWHITE CHAR
SW20:
	CP '['				;TEST FOR COMMENT
	RET NZ				;RETURN IF NOT
	CALL SKIPCOMM
	LD (NXTCHR),A		;SAVE NEXT
	JR SKIPW			;AND TRY AGAIN

SKIPCOMM::
	CALL CHRIN
SK10:
	CP 26				;END OF FILE?
	JP Z,READERR		;YES
	CP ']'				;END OF COMMENT?
	JR Z,CHRIN			;YES RETURN NEXT CHAR
	CP '['				;NESTED COMMENTS?
	JR NZ,SKIPCOMM		;NO
	CALL SKIPCOMM
	JR SK10

CHRIN:
	LD HL,(IOCHAN)
	LD A,H
	OR A
	JR Z,CIN		;CONSOLE IN
	LD A,(HL)
	OR A			;OPEN?
	JP NZ,GETC0		;YES
	JP FILERR

;***************;
; CONSOLE INPUT ;
;***************;
CIN::
	LD A,(LDFLG)
	OR A				;LOAD?
	JR Z,CONIN			;NO
	LD HL,DFLTF			;DEFAULT FILE
	CALL GETC0			;GET CHAR
	CP EOFCHR			;END OF FILE?
	RET NZ				;NO
	CALL INIBUF			;CLEAR BUFFER
CONIN::
	LD HL,(LBP)			;GET LINE BUFFER PTR
	LD A,(HL)			;GET CHAR
	OR A				;END OF LINE?
	JR Z,CI10			;YES
	INC HL				;ELSE INC LBP
	LD (LBP),HL
	RET
CI10:
	LD A,(LEVEL)		;DISPLAY LEVEL
	CP '0'				;IF NOT ZERO
	JR Z,CI15
	CALL CHROUT
CI15:
	BDOS 11				;CHECK CONSOLE STATUS
	OR A				;CHAR PRESENT?
	JR Z,CI17			;NO
	BDOS 1				;ELSE DROP IT
CI17:
	PRINT ":"			;AND PROMPT
	LD HL,LBUF			;HL ON BEGINNING OF LINE BUFFER
	LD C,0				;CLEAR CHAR COUNT
CI20:
	CALL $KEY			;DIRECT CONSOLE IN
	JR Z,CI20
	CP 13				;RETURN?
	JR NZ,CI30
	LD (HL),A			;STORE THE CR
	INC HL
	LD A,LLEN+1			;CLEAR REST
	SUB C
	LD B,A
	XOR A
CI25:
	LD (HL),A
	INC HL
	DJNZ CI25
	LD HL,LBUF
	LD (LBP),HL
	CALL CR_LF
	JR CONIN
CI30:
	CP 'H'-'@'			;BACKSPACE?
	JR NZ,CI40
	LD A,C				;TEST COUNT
	OR A
	JR Z,CI20			;DO NOTHING IF ZERO
	CALL DOBS
	JR CI20
CI40:
	CP 'X'-'@'			;^X
	JR NZ,CI50
CI45:
	LD A,C				;KILL LINE
	OR A
	JR Z,CI20
	CALL DOBS
	JR CI45
CI50:
	CP 'I'-'@'			;TAB
	JR NZ,CI60
	LD B,4				;EXPAND TO 4 SPACES
CI55:
	LD A,' '
	CALL ECHO
	DJNZ CI55
	JR CI20
CI60:
	CP 'R'-'@'			;^R
	JR NZ,CI70
CI65:
	LD A,(HL)			;RETYPE
	OR A
	JR Z,CI20
	CP 13
	JR Z,CI20
	CALL ECHO2
	JR CI65
CI70:
	CP 'C'-'@'			;^C
	JP Z,RESET
CI80:
	CALL ECHO			;ANY OTHER CHARACTER
	JR CI20

ECHO::
	LD (HL),A			;STORE CHAR
	LD A,C
	CP LLEN				;CHECK OVERFLOW
	RET NC
ECHO2:
	INC C
	LD A,(HL)			;GET CHAR AGAIN
	CP ' '				;WHITE?
	JR NC,EC10			;NO
	LD A,'_'			;ELSE MAKE PRINTABLE
EC10:
	INC HL
	JR CHROUT			;PRINT IT

DOBS::
	DEC C
	DEC HL
	LD A,8				;OUT BACKSPACE
	CALL CHROUT
	CALL SPACE			;OUT SPACE
	LD A,8				;OUT BACKSPACE
	JR CHROUT

;OUT SPACE
SPACE::
	LD A,32
	JR CHROUT

;MESSAGE OUT
MSG$PC::
	EX (SP),HL			;RETURN ADDRESS IN HL
	CALL PR$HL			;PRINT STRING
	EX (SP),HL			;NEW RETURN ADDRESS
;OUT NEWLINE SEQUENCE
CR_LF::
	LD A,13				;CARRIAGE RETURN
	CALL CHROUT
	LD A,10				;LINE FEED
;***************;
; CHARACTER OUT ;
;***************;
CHROUT::
	PUSH HL
	PUSH BC
	PUSH AF
	LD HL,(IOCHAN)
	LD A,H
	OR A
	JR Z,COUT		;CONSOLE OUT
	LD A,(HL)
	OR A			;OPEN?
	JP Z,FILERR		;NO
	POP AF
	CALL PUTC0
	JR CORET

COUT:
	POP AF
;;	CP 'I'-'@'
;;	JR Z,TABOUT
	LD E,A			;CHAR
	BDOS 2			;CONSOLE OUT
CORET:
	POP BC
	POP HL
	RET

;;TABOUT:
;;	LD BC,0402H		;OUT 4 SPACES TO BDOS 2
;;TO10:
;;	PUSH BC
;;	LD E,' '
;;	CALL 5
;;	POP BC
;;	DJNZ TO10
;;	JR CORET

;****************;
; PRINT ROUTINES ;
;****************;
;PRINT STRING AT PC
PR$PC::
	EX (SP),HL			;RETURN ADDRESS IN HL
	CALL PR$HL			;PRINT STRING
	EX (SP),HL			;NEW RETURN ADDRESS
	RET

;PRINT STRING AT HL
PR$HL::
	LD A,(HL)			;NEXT CHAR
	AND 7FH
	CALL CHROUT			;CHAR OUT
	BIT 7,(HL)
	INC HL				;NEXT
	RET NZ
	JR PR$HL

PUTC::
	PUSH HL			;RETURN VALUE
	CALL FADRDE		;SET CHANNEL NO
	LD (IOCHAN),DE
	CALL MBYTE
	CALL CHROUT
	JR PRET1

GETC::
	CALL FADRHL		;SET CHANNEL NO
	LD (IOCHAN),DE
	CALL CHRIN
	LD L,A
	LD H,0
	CALL SELCON
	JP BOXHL

;TOP LEVEL PRINT
PRINT::
	PUSH HL			;SAVE ARG
	PUSH DE			;AND CHANNEL
	CALL PRIN1		;PRINT ARG
	POP HL			;AND A NEWLINE
	CALL CRLF
	JR PRET1

CRLF::
	CALL FADRHL		;SET CHANNEL NO
	LD (IOCHAN),DE
	CALL CR_LF		;PRINT NEWLINE SEQUENCE
	JR PRET2

SPC::
	CALL FADRHL		;SET CHANNEL NO
	LD (IOCHAN),DE
	CALL SPACE		;PRINT SPACE
	JR PRET2

PRIN1::
	CALL FADRDE		;SET CHANNEL NO
	LD (IOCHAN),DE
	PUSH HL
	CALL PRIN0		;PRINT ARG
PRET1:
	POP HL
PRET2:
	JP SELCON

;PRINT NIL
PRNIL::
	PRINT "nil"
	RET

;PRINT ARGUMENT IN HL
PRIN0::
	LD A,H				;NIL?
	OR A
	JR Z,PRNIL			;YES
	LD A,(HL)			;GET TAG
	RRCA				;CELL?
	JR C,PRCELL			;YES
PRATOM::
	LD A,(HL)			;GET TAG
	RLCA				;NUMBER?
	JR C,PRNUM			;YES
	LD BC,9				;OFFSET TO NAME
	ADD HL,BC
	JR PR$HL			;PRINT SYMBOL
PRCELL::
	PRINT '('			;LIST OR DOTTED PAIR
PRBODY::
	LD E,(HL)			;CAR
	INC HL
	LD D,(HL)
	INC HL
	PUSH HL				;PUSH PTR TO CDR
	EX DE,HL
	CALL PRIN0			;PRINT CAR
	POP HL				;RETRIEVE CDR
	LD A,(HL)
	OR A				;NIL?
	JR Z,PB20			;YES
	LD D,A
	INC HL
	LD E,(HL)
	EX DE,HL			;CDR IN HL
	LD A,(HL)
	RRCA				;CELL?
	JR NC,PB10			;NO
	CALL SPACE
	PUSH HL
	CALL BRKEY			;CHECK CONSOLE BREAK
	POP HL
	JR NC,PRBODY		;PRINT REST OF LIST
	PRINT "..."			;ELSE EXIT IF BREAK
	JR PB20
PB10:
	PRINT " . "			;DOTTED PAIR
	CALL PRATOM
PB20:
	PRINT ')'			;DONE
	RET

PRNUM::
	INC HL				;INC TO NUMBER
	EX DE,HL
	LD HL,(HEAPTR)		;MOVE TO HEAP
	CALL MOOV
	PUSH HL
	LD BC,MAXNUM+1		;OFFSET TO WORKSPACE
	ADD HL,BC
	LD (HL),0			;INIT WORKSPACE TO ZERO
	EX (SP),HL
	LD A,(HL)			;SIGN?
	RLA
	JR NC,PN10			;NO
	SRL A				;CLEAR SIGN
	LD (HL),A
	PRINT '-'			;PRINT IT
PN10:
	LD A,(HL)
	OR A				;CONVERSION DONE?
	JR Z,PN20			;YES
	EX DE,HL			;DE ON HEAP
	LD HL,BASE
	CALL MOD0			;SPLIT OFF NEXT DIGIT
	EX DE,HL
	INC HL
	LD A,(HL)			;DIGIT
	DEC HL
	EX (SP),HL			;POINT TO WORKSPACE
	CALL PSHL			;PUSH DIGIT
	EX (SP),HL
	LD DE,T2			;GET RESULT
	CALL MOOV
	JR PN10
PN20:
	POP HL				;TO WORKSPACE
	LD A,(HL)			;GET COUNT
	OR A				;ZERO?
	JR NZ,PN30			;NO
	PRINT "0"			;ELSE OUTPUT ZERO
	RET
PN30:
	LD B,A				;COUNT
PN40:
	INC HL
	LD A,(HL)			;GET NEXT DIGIT
	ADD A,'0'			;MAKE ASCII
	CP '9'+1
	JR C,PN50
	ADD A,7
PN50:
	CALL CHROUT			;PRINT DIGIT
	DJNZ PN40			;REPEAT
	RET

	END
